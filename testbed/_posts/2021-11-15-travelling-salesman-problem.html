---
title:  "Travelling salesman problem"
layout: post
hashtag: "#genetic-algorithm #optimization"
featured: true
comment: true
thumbnail: /img/tsp-6.png
---

<div id="toc"></div>
<h3>What is the Genetic Algorithm 🧬</h3>
<div class="article">
    <a href="https://en.wikipedia.org/wiki/Genetic_algorithm">Genetic algorithms</a> are commonly used to generate high-quality solutions to optimization and search problems relying on inspiration from biology such as mutation, crossover,  and selection.
    It is a metaheuristic inspired by the process of <code>natural selection</code> of biology that belongs to the larger class of evolutionary algorithms.
    <br><br>
    And this algorithm has characteristics following below:
    <!--break-->
    <ul style="padding-left: 2em;">
        <li>A <code>population</code> of candidate solutions to an optimization problem is evolved toward better solutions</li>
        <li>Each candidate solution has a set of properties which can be <code>mutated</code></li>
        <li>The evolution usually starts from a population of randomly generated individuals</li>
        <li>It is an iterative process, with the population in each <code>iteration called a generation</code></li>
        <li>The <code>fitness</code> of every individual in the population is evaluated
            <ul><li>the fitness is usually the value of the <code>objective function</code> in the optimization problem being solved</li></li></ul>
        <li>The more fit individuals are stochastically selected from the current population </li>
        <li>Each individual's genome is modified (recombined and possibly randomly mutated) to form a new generation</li>
        <li>Commonly, the algorithm terminates when either:
            <ul><li>a maximum number of generations has been produced</li></ul>
            <ul><li>a satisfied fitness level has been reached for the population</li></ul>
    </ul>    
    <br>
</div><br>

<h3>Simple implementation; Lucky numbers generator</h3>
<div class="article">
    Set the simple goal to optimize, and let's implement the genetic algorithm simply.
    The goal is to make chromosomes, which own <code>seven lucky numbers(7)</code>, and then make a genome, which has seven chromosomes again. like the below:

<pre class="highlight"><code class="python">
    <span class="method">GENE_COUNT</span> = 7
    <span class="method">CHROMOSOME_COUNT</span> = 7
    <span class="method">GENERATION_LIMIT</span> = 777

    <span class="gu"># The goal genome is configured 7 x 7 matrix and each gene is `7`</span>
    goal_genome => [[7, 7, 7, 7, 7, 7, 7],
                    [7, 7, 7, 7, 7, 7, 7],
                    [7, 7, 7, 7, 7, 7, 7],
                    [7, 7, 7, 7, 7, 7, 7],
                    [7, 7, 7, 7, 7, 7, 7],
                    [7, 7, 7, 7, 7, 7, 7],
                    [7, 7, 7, 7, 7, 7, 7]]  


    <span class="gu"># This is the way to create the genome</span>
    def <span class="defName">generate_genome</span>(self):
        genome = []
        for _ in range(self.<span class="method">GENOME_COUNT</span>):
            chromosome = []
            for _ in range(self.<span class="method">GENE_COUNT</span>):
                gene = random.<span class="defName">randint</span>(0, 9)
                chromosome.append(gene)
            genome.append(chromosome)
        return genome    
</code></pre><br>

You can check the method to create the genome the above.
<br><br>

Now we need a <code>fitness function</code> to evaluate each genome in each generation. It is possible to get by subtracting lucky numbers from each gene and adding all chromosome scores. 
For example, we assume to have a chromosome that has numbers following: <code>[1, 7, 6, 5, 9, 3, 2]</code>.
By calculating the difference between each number generated by the <code>generate_genome</code> function and <code>7</code>, converting it into an absolute value, be able to evaluate the fitness of each gene.
In this example, the fitness of each gene is the following: <code>[1, 7, 6, 5, 9, 3, 2] => [6, 0, 1, 2, 2, 4, 5]</code>
<br><br>
And if all fitnesses are <code>0</code>, terminate the evolution before the generation number is maximum.

<figure>
    <img src="../img/tsp-1.png" style="width: 80%;">
    <figcaption>Make each gene into the dominant factor
    </figcaption>
</figure><br>

Next, we need a process to select parent chromosomes and <code>crossover</code> selected chromosomes.
The method of chromosomes selection is determined as a sum of fitnesses, and the closer the sum is to 0, the better the chromosome.

There are several crossover methods, but here we will use uniform crossover. <code>Uniform crossover</code> carries the following out.
The uniform crossover method randomly selects one of the parent chromosomes to <code>mask</code> the genes of the parent chromosome and assign the masked gene to the child chromosome.
A description of the uniform crossover is explained in <a href="https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)#Uniform_crossover">here</a> more detail, and the implementation of it is below.

<pre class="highlight"><code class="python">
    def <span class="defName">reproduction_genome</span>(self, parent_chromosome, child_chromosome, best_parents_indices):
        for i in range(self.<span class="method">GENOME_COUNT</span>):
            for j in range(self.<span class="method">GENE_COUNT</span>):
                if random.random() < self.<span class="method">MUTATION_RATE</span>:
                    mutated_gene = random.<span class="defName">randint</span>(0, 9)
                    child_chromosome[i][j] = mutated_gene
                else:
                    idx = random.<span class="defName">randint</span>(0, 1)
                    selected_parent = best_parents_indices[idx]
                    crossoverd_gene = parent_chromosome[selected_parent][j]
                    child_chromosome[i][j] = crossoverd_gene
</code></pre>

<br>
Lastly, iterate the above processes. That's all. 
In this example, we can get the result we want simply before reaching the maximum generation (777) because we set a simple objective.

<figure>
    <img src="../img/tsp-2.png" style="width: 70%;">
    <figcaption>Evaluate fitness per each generation
    </figcaption>
</figure><br>

</div>

<script
	type="text/javascript"
    async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_HTML"
></script>


<h3>Travelling salesman problem</h3>
<div class="article">
    
    The travelling salesman problem (also called the travelling salesperson problem or <code>TSP</code>) is one of the famous problems in the computer science area.
    This problem is to visit all cities only once and find the order of the minimum distance of moving back to the original starting point.
    In this problem, we receive several <code>cities</code> and <code>coordinates</code> of cities as input.
    
    <figure>
        <img src="../img/tsp-3.png" style="width: 60%; margin-top: 2em;">
        <figcaption style="margin-top: 2em;"><a href="https://mathworld.wolfram.com/TravelingSalesmanProblem.html">Travelling salesman problem</a> <br>
            From the left, Coordinates of cities · The shortest distance of visit
        </figcaption>
    </figure><br>
    
    Genome is the order of cities to visit when there are coordinates of given cities. 
    And the first and last in the visit sequence must be the same origin point.
    For example, given 20 cities and an origin (0), the genome can be created as follows: 
    <code>[0, 12, 10, 17, 14, 3, 11, 5, 19, 16, 8, 7, 1, 9, 15, 4, 6, 13, 2, 18, 0]</code>.

    <br><br>
    The fitness of the genome is determined by the sum of the distances of visits in the current order(indices) through the formula for <a href="https://en.wikipedia.org/wiki/Euclidean_distance">calculating the distance between two points</a>.
    If the coordinates of the city are given as follows, and the genome is in the sequence shown above, it is calculated as shown in the figure below.
    
<pre class="highlight"><code class="python">
    city_coordinates = [[217, 314], [328, 294], [394, 269], [272, 337], [485, 210],
                        [328, 371], [418, 340], [299, 353], [247, 230], [158, 377],
                        [139, 285], [153, 389], [100, 364], [395, 286], [247, 349],
                        [236, 227], [422, 370], [207, 279], [356, 232], [312, 350]]
    
    genome = [0, 12, 10, 17, 14, 3, 11, 5, 19, 16, 8, 7, 1, 9, 15, 4, 6, 13, 2, 18, 0]
    
    
    def <span class="defName">evaluate_distance</span>(self, city_1, city_2):
        x1, y1 = city_1
        x2, y2 = city_2
        distance = math.<span class="defName">sqrt</span>((x2-x1)**2 + (y2-y1)**2)
        return distance
    
    distances = [127.24, 88.1, 68.26, 80.62, 27.73, 129.87, 175.92, 26.4, 111.8, 224.11, 
                 133.54, 65.74, 189.18, 169.07, 249.58, 146.25, 58.69, 17.03, 53.94, 161.38]
    
    fitness = sum(distances)
</code></pre><br>
    
    And this time, we will use the <code>order one crossover</code> method among the crossover methods.
    First, part of the <code>parent_1</code> genome is randomly sliced and assigned to the <code>offspring</code> genome.
    And the rest are given genes from the <code>parent_2</code> genome to create an offspring genome.
    <!-- 또한, 임의의 확률로 도시 방문 순서를 바꿔주는 mutation 기능을 추가할 수도 있습니다. Fig.4 이미지의 가장 아래 mutated 부분을 참조하세요. -->

    We can add a function to mutate that changes cities visit order via randomly probability also.

    <br><br>
    Please refer the <a href="https://github.com/PARKCHEOLHEE-lab/ToyProjects/blob/f8eeb81a975b0b16700230c941334cec4087c7c7/genetic_algorithm/TSP.py#L111-L151">github link</a> to see the order one crossover or mutation related code.
    
    <figure>
        <img src="../img/tsp-5.png" style="width: 70%; margin-top: 2em;">
        <figcaption style="margin-top: 2em;">
            Conception of the order one crossover 
        </figcaption>
    </figure><br>

    Lastly, sets a threshold value. It is used to remove the genome in the population if fitness is less than the threshold we set. 

<pre class="highlight"><code class="python">
    population = [[0, 12, 10, 17, 14, 3, 11, 5, 19, 16, 8, 7, 1, 9, 15, 4, 13, 2, 18, 0]
                  [0, 1, 3, 17, 14, 10, 11, 5, 4, 16, 8, 7, 12, 9, 15, 19, 18, 13, 2, 6, 0]

                                                    .
                                                    .
                                                    .

                  [0, 17, 1, 12, 15, 3, 6, 7, 19, 16, 8, 5, 10, 9, 14, 4, 11, 13, 18, 2, 0]]
                  
    if fitness > self.weakness_threshold:
        population.remove(genome)
</code></pre><br>
    The image below compares with threshold and without threshold.
    You can see that applying a threshold finds the shortest path in an earlier generation than the version without applying it.
    
    <figure style="display:flex;">
        <img src="../img/tsp-4.gif" style="width: 45%; margin-top: 2em;">
        <img src="../img/tsp-5.gif" style="width: 45%; margin-top: 2em;">
        
    </figure><br>
    <figcaption>Calculate minimum distance<br>
        From the left, With threshold, Without threshold
    </figcaption>
    
</div>

<br><br>