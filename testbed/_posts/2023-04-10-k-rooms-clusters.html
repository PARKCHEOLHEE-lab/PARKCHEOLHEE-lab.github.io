---
title:  "K-Rooms clusters"
layout: post
hashtag: "#unsupervised-learning #machine-learning"
featured: true
---


<div id="toc"></div>
<h3>K-Means clustering ðŸ•ƒ</h3>
<div style='text-align: justify;'>
    The <a href="https://ko.wikipedia.org/wiki/K-%ED%8F%89%EA%B7%A0_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">K-Means</a> clustering algorithm is the algorithm 
    that clusters to a <code>K number</code> when given data.
    And it operates as a way to minimize 
    between each cluster about distance difference.
    This algorithm is a type of the Unsupervised-Learning and <code>serves to label</code> unlabeled input data.

    <!--break-->

    <br><br>

    The K-Means algorithm belongs to a partitioning method among clustring method.
    A partitioning method is a way of splitting that divides multiple partitions when given data.
    For example, let's assume that n data objects are input. That's when partitioning method divides the given data into <code>K</code> groups less than <code>N</code>, at this time, each group forms a cluster.
    That is, dividing a piece of data into one or more data objects.

    <figure>
        <img src="../img/k-rooms-0.png" style="width: 70%; display: block; margin-left: auto; margin-right: auto;">
        <figcaption style="text-align: center; margin-top: 1em">
            <a href="https://www.askpython.com/python/examples/plot-k-means-clusters-python">K-means clustering</a>, divided by 10
        </figcaption>
    </figure>
    
</div>
<br><br>
<h3>Implementation</h3>
<div style="text-align: justify;">
    The operation flow of the K-Means clustering consists of 5 steps following:
    <ul style="padding-left: 2em;">
        <li class="decimal">Select up a K (the count of clusters) and enter data</li>
        <li class="decimal">Set initial centroids of clusters randomly</li>
        <li class="decimal">Assign the data to each cluster based on the nearest centroid</li>
        <li class="decimal">Recalculate the new centroids of clusters and re-execute step-4</li>
        <li class="decimal">Terminate if no longer locations of centroids aren't updated</li>
    </ul>

    <br><br>

    Let's implement the K-Means algorithm based on the steps above. First, we define the <code>KMeans</code> object.
    As input, it receives the <code>number of clusters(K)</code> to divide, <code>points cloud</code>, 
    and <code>iteration_count</code> which is the number of centroid update iterations

    
<pre class="highlight">
    class KMeans(PointHelper):
        def __init__(self, points=None, k=3, iteration_count=20, random_seed=0):
            """KMeansCluster simple implementation using Rhino Geometry
    
            Args:
                points (Rhino.Geometry.Point3d, optional): Points to classify. Defaults to None. if points is None, make random points
                k (int, optional): Number to classify. Defaults to 3.
                iteration_count (int, optional): Clusters candidates creation count. Defaults to 20.
                random_seed (int, optional): Random seed number to fix. Defaults to 0.
            """
    
            PointHelper.__init__(self)
    
            self.points = points
            self.k = k
            self.iteration_count = iteration_count
            self.threshold = 0.1
    
            import random  # pylint: disable=import-outside-toplevel
    
            self.random = random
            self.random.seed(random_seed)
</pre>

    <br><br>

    Next, Initialize the centroids of clusters as much as the number of K by <code>selecting the given points cloud as much as K randomly.</code>
    If the initial centroid setting is done, <code>calculate the distance</code> between each centroid and the given points cloud, 
    and assign the data at the cluster which is the closest distance.
    
    Now we should update all the centroids of clusters. 
    We need to <a href="https://github.com/PARKCHEOLHEE-lab/ghpythonutils/blob/15fbd324250c5059a758fbe97e81fc82c72ec02a/utils/utils.py#L505-L517">
        compute centroids of initial clusters(points cloud clusters)
    </a> for that.

    <br><br>
    
    Finally, compute the distance between the updated centroid and the previous centroid. 
    If this distance does not no longer changes, terminate. Otherwise, just iterate on key things which are explained above.

    <br><br>

<pre class="highlight">
        def kmeans(self, points, k, threshold):
            """Clusters by each iteration

            Args:
                points (Rhino.Geometry.Point3d): Initialized given points
                k (int): Initialized given k
                threshold (float): Initialized threshold

            Returns:
                Tuple[List[List[Rhino.Geometry.Point3d]], List[List[int]]]: Clusters by each iteration, Indices by each iteration
            """

            centroids = self.random.sample(points, k)

            while True:
                clusters = [[] for _ in centroids]
                indices = [[] for _ in centroids]

                for pi, point in enumerate(points):
                    point_to_centroid_distance = [
                        point.DistanceTo(centroid) for centroid in centroids
                    ]
                    nearest_centroid_index = point_to_centroid_distance.index(
                        min(point_to_centroid_distance)
                    )

                    clusters[nearest_centroid_index].append(point)
                    indices[nearest_centroid_index].append(pi)

                shift_distance = 0.0
                for ci, current_centroid in enumerate(centroids):
                    if len(clusters[ci]) == 0:
                        continue

                    updated_centroid = self.get_centroid(clusters[ci])
                    shift_distance = max(
                        updated_centroid.DistanceTo(current_centroid),
                        shift_distance,
                    )

                    centroids[ci] = updated_centroid

                if shift_distance < threshold:
                    break

            return clusters, indices
</pre>
<br><br>
Now we can get the point clusters by setting the K, from the code below. 

<pre class="highlight">
    from ghpythonutils.utils.kmeans.kmeans import KMeans
    from ghpythonlib.treehelpers import list_to_tree
    import rhinoscriptsyntax as rs
    import random
    
    kmeans = KMeans(points=points, k=10, random_seed=90)
    points_clusters = kmeans.predict()
    points_clusters = list_to_tree(points_clusters)
    
    points_clusters_colors = []
    for branch in points_clusters.Branches:
        
        r = random.randint(0, 255)
        g = random.randint(0, 255)
        b = random.randint(0, 255)
        
        points_clusters_colors.append(
            [rs.CreateColor(r, g, b)] * len(branch)
        )
    
    points_clusters_colors = list_to_tree(points_clusters_colors)
</pre>


And you can see the detailed code for the K-Means at this <a href="https://github.com/PARKCHEOLHEE-lab/ghpythonutils/blob/main/utils/kmeans/kmeans.py">link</a>.

<figure>
    <img src="../img/k-rooms-1.png" style="width: 100%; display: block; margin-left: auto; margin-right: auto;">
    <figcaption style="text-align: center; margin-top: 1em">
        <a href="https://www.askpython.com/python/examples/plot-k-means-clusters-python">Implemented K-means clustering</a>, divided by 10 <br> From the left, Given Points Â· Result clusters     
    </figcaption>
</figure>
<br>
</div>
<h3>K-Rooms Clusters</h3>


<br><br>
