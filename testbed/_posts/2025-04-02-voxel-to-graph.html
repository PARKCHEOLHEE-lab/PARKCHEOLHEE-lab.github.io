---
title: "Voxel to Graph"
layout: post
hashtag: "#graph #gnn #building-gan"
comment: true
splitter: 1
featured: false
inprogress: false
thumbnail: /img/voxel-to-graph/voxel-to-graph-thumbnail.gif
---

<div id="toc"></div>

<h3>Introduction 🔗</h3>
<div class="article">
    This project explores the key contributions of <a href="https://arxiv.org/pdf/2104.13316">Building-GAN</a> by AutodeskAILab: 
    1) a novel 3D representation called <strong>voxel graph</strong> that can encode <strong>irregular voxel grids</strong> with non-uniform space partitioning, overcoming limitations of traditional regular voxel grids, and 
    2) a graph-conditioned generative adversarial network (GAN) leveraging graph neural networks (GNNs). 
    The implementation uses their <a href="https://github.com/AutodeskAILab/Building-GAN?tab=readme-ov-file">dataset</a> to study these approaches.

    <figure>
        <img src="/img/voxel-to-graph/voxel-to-graph-0.png" width="100%" onerror=handle_image_error(this)>
        <figcaption>
          Generated Buildings
        </figcaption>
    </figure>

</div><br><br>

<h3>Data Structure</h3>
<div class="article">

    In the Data Collection part of the paper, it says that the dataset was created as follows:
    <br><br>
    Since there is no publicly available dataset for volumetric designs from real buildings, we create a synthetic
    dataset with 120,000 volumetric designs for commercial buildings using parametric models. 
    The heuristics behind the parametric models are based on the rules and knowledge provided by professional architects. 
    
    <!--break-->
    
    Although these parametric models are able to explore possible volumetric designs, they are not capable of fitting the constraints.
    Therefore, we generate the designs first and then compute the voxel graph, program graph, FAR, and TPR for each design. 

    <!-- <br><br> -->

    (...)

    <!-- <br><br> -->

    
    <strong>Here, we consider 6 program types: lobby/corridor, restroom, stairs, elevator, office, and mechanical room.</strong> 
    Each program node feature includes the program type and the story level.

    <br><br>

    Each datum of the created dataset consists of three JSONs as follows:
    <ol>
        <li>
            <strong>graph_global_*.json</strong>: 
            contains the FAR (Floor Area Ratio), program ratios, and program types (6 program types described above + void type).

<pre><code class="json">
    {
        "far": 3.1144640998959425,
        "global_node": [
            {
                "type": 3,
                "proportion": 0.04811226194453724,
            
                (...)
            },
            {
                "type": 0,
                "proportion": 0.25526227865018364,
            
                (...)
            },

            (...)
        ]
    }
</code></pre>
<figcaption class="nofig">
    graph_global_*.json
</figcaption><br>
        </li>
        <li>
            <strong>graph_local_*.json</strong>: 
            contains the nodes. 
            Each node has the following attributes:
            floor \(\text{F}\) (the floor level on which the node is placed), 
            program type \(\text{T}\), index \(\text{I}\), and neighbors that indicate connectivity between nodes.
            In the local graph, the unique index of each node is created as \(\text{[F, T, I]}\), 
            and the neighbors contain these unique indices.
            In the example below, the first node's unique index is \(\text{[0, 3, 0]}\), 
            and it has \(\text{[1, 3, 0]}\) as a neighbor. 
            Similarly, the node with index \(\text{[1, 3, 0]}\) has \(\text{[0, 3, 0]}\) as a neighbor.
<pre><code class="json">
    {
        "node": [
            {
                "floor": 0,
                "type": 3,
                "type_id": 0,
                "neighbors": [[0, 0, 0], [1, 3, 0]]
            
                (...)
            },
            {
                "floor": 1,
                "type": 3,
                "type_id": 0,
                "neighbors": [[1, 0, 0], [2, 3, 0], [0, 3, 0]]
            
                (...)
            },
            
            (...)
        ]
    }
</code></pre>
<figcaption class="nofig">
    graph_local_*.json
</figcaption><br>
        </li>
        <li>
            <strong>voxel_*.json</strong>: 
            contains the voxel voxel nodes. Each voxel node has the following attributes: 
            location (it serves as a unique index in the voxel graph), 
            program type, 
            dimension (depth, height, width of an irregular voxel), 
            and neighbors that indicate connectivity between nodes.

<pre><code class="json">
    {
        "voxel_node": [
            {
                "location": [0, 2, 7],
                "type": 3,
                "dimension": [7.0, 3.0, 3.0],
                "neighbors": [[1, 2, 7], [0, 1, 7], [0, 3, 7], [0, 2, 6]]
            
                (...)
            },
            {
                "location": [1, 2, 7],
                "type": 3,
                "dimension": [4.0, 3.0, 3.0],
                "neighbors": [[0, 2, 7], [2, 2, 7], [1, 1, 7], [1, 3, 7], [1, 2, 6]]
            
                (...)
            },
            
            (...)
        ]
    }
</code></pre>
<figcaption class="nofig">
    voxel_*.json
</figcaption><br>
        </li>
    </ol>

</div><br><br>

<h3>Representing Voxel as Graph</h3>
<div class="article">

    
    A Graph data structure consists of vertices and edges \(G(V, E)\).
    The vertices are sometimes also referred to as nodes 
    and the edges are lines or arcs that connect any two nodes in the graph.

    <!-- 
        그래프 표현은 adjacency list(or matrix) 와 같은 노드의 연결 관계로 나타낸다.
        ...
        
        복셀데이터를 이러한 그래프 구조로 바꾸기 위해서 다음과 같은 방식을 사용할 수 있다.
        1.
        2.
        3.

        아래 그림은 이를 단순화하여 시각화한 다이어그램이다.
    -->
    <figure>
        <img src="/img/voxel-to-graph/voxel-to-graph-1.png" width="100%" onerror=handle_image_error(this)>
        <figcaption>
          Voxel to Graph
        </figcaption>
    </figure>

    <!-- 
        복셀 노드의 인덱스는 (x,y,z) 구조로 되어있고, 이를 0, 1, 2 구조로 바꿔주어야 함. 
        x,y,z 형태의 인덱스는 유니크하므로 단순히 0,1,2 ... n 의 형태로 전환 가능.

        x -> node feature
        edge_index -> connection

        each voxel has unique index:
            (0,0,0) -> 0
            (0,0,1) -> 1

                (...)

            (n,m,o) -> ?

        if voxels have the same assignment and are adjacent to each other,
        it means that they are connected in the graph representation
    -->
</div><br><br>

<h3>Modeling</h3>
<div class="article">
    <!-- 
        voxel-wise node class prediction
        matched_x, voxel-wise z concat
        gumbel softmax
        sanity checking
    -->
</div><br><br>

<h3>Training</h3>
<div class="article">
</div><br><br>

<h3>Qualitative Evaluation</h3>
<div class="article">
</div><br><br>

<h3>References</h3>
<div class="article">
    <ul>
        <li>
            <a href="https://arxiv.org/pdf/2104.13316">https://arxiv.org/pdf/2104.13316</a>
        </li>
        <li>
            <a href="https://arxiv.org/pdf/1406.2661">https://arxiv.org/pdf/1406.2661</a>
        </li>
        <li>
            <a href="https://kaen2891.tistory.com/81">https://kaen2891.tistory.com/81</a>
        </li>
    </ul>
</div><br><br>

<br><br>